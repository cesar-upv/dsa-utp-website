\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath,amssymb}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\usepackage{tikz}
\usetikzlibrary{trees,arrows,shapes}

\geometry{margin=2.5cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{pseudocode}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single
}

\title{\textbf{Algoritmos de Generación de Horarios Universitarios}}
\author{Backend del Sistema de Scheduling}
\date{\today}

\begin{document}

\maketitle

\tableofcontents
\newpage

\section{Introducción}

Este documento describe los algoritmos implementados en el backend del generador de horarios universitarios. El sistema utiliza dos algoritmos principales: \textbf{Greedy} (voraz) para generación rápida y \textbf{Backtracking} (retroceso) para búsqueda exhaustiva con garantías de completitud.

\section{Estructuras de Datos}

\subsection{Nodo (Node)}

Representa una \textbf{hora-clase} que debe ser asignada. Cada materia con $N$ horas semanales genera $N$ nodos independientes.

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Campo} & \textbf{Tipo} & \textbf{Descripción} \\
\midrule
id & string & Identificador único: ``grupo-materia-unidad'' \\
grupo\_id & string & ID del grupo estudiantil \\
materia\_id & string & ID de la materia \\
unit\_index & int & Índice de la hora (0, 1, 2...) \\
possible\_assignments & list & Lista de tuplas (día, slot, profesor) \\
assigned\_day & int & Día asignado (-1 si no asignado) \\
assigned\_slot & int & Slot asignado (-1 si no asignado) \\
assigned\_prof & int & Índice del profesor asignado \\
\bottomrule
\end{tabular}
\caption{Estructura del Nodo}
\end{table}

\textbf{Ejemplo:} Una materia ``Cálculo'' con 4 horas semanales para el grupo ``ISC-1A'' genera 4 nodos:
\begin{itemize}
    \item ISC-1A-calculo-0
    \item ISC-1A-calculo-1
    \item ISC-1A-calculo-2
    \item ISC-1A-calculo-3
\end{itemize}

\subsection{Matrices de Estado}

El sistema utiliza matrices NumPy para verificaciones en tiempo $O(1)$:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Matriz} & \textbf{Dimensiones} & \textbf{Propósito} \\
\midrule
prof\_schedule & $[P \times 5 \times 9]$ & 1 si profesor ocupado, 0 si libre \\
group\_schedule & $[G \times 5 \times 9]$ & 1 si grupo ocupado, 0 si libre \\
prof\_load & $[P]$ & Carga actual de cada profesor \\
prof\_max\_load & $[P]$ & Carga máxima permitida \\
group\_materia\_day\_count & $[G \times M \times 5]$ & Horas por materia/grupo/día \\
group\_materia\_day\_slots & $[G \times M \times 5]$ & Bitmask de slots ocupados \\
\bottomrule
\end{tabular}
\caption{Matrices de Estado ($P$ = profesores, $G$ = grupos, $M$ = materias)}
\end{table}

\newpage
\section{Algoritmo Greedy (Voraz)}

\subsection{Definición}

El algoritmo \textbf{Greedy} es una estrategia de resolución de problemas que toma decisiones \textbf{localmente óptimas} en cada paso, con la esperanza de que estas decisiones conduzcan a una solución global aceptable.

\subsection{Complejidad}

\begin{equation}
O(N \times A)
\end{equation}

Donde $N$ = número de nodos y $A$ = asignaciones posibles por nodo.

\subsection{Funcionamiento Paso a Paso}

\begin{enumerate}
    \item \textbf{Ordenamiento inicial:} El sistema recibe una lista de ``nodos'' (horas-clase) que deben ser asignadas. Cada nodo representa una hora específica de una materia para un grupo determinado.
    
    \item \textbf{Iteración secuencial:} El algoritmo recorre cada nodo en orden. Para cada nodo, tiene una lista de ``asignaciones posibles'' que son combinaciones válidas de (día, horario, profesor).
    
    \item \textbf{Selección de la primera opción válida:} Para cada nodo, el algoritmo prueba las asignaciones posibles una por una. La primera que pase todas las validaciones se aplica inmediatamente.
    
    \item \textbf{Sin retroceso:} Una vez que se asigna un nodo, esa decisión es \textbf{permanente}. El algoritmo nunca vuelve atrás para cambiar una asignación anterior.
    
    \item \textbf{Manejo de fallos:} Si ninguna asignación es válida para un nodo, se deja sin asignar y se genera una advertencia.
\end{enumerate}

\subsection{Pseudocódigo}

\begin{lstlisting}[style=pseudocode, caption={Algoritmo Greedy}]
funcion solve_greedy():
    Para i desde 0 hasta cantidad_de_nodos:
        nodo = nodos[i]
        grupo_idx = obtener_indice_grupo(nodo.grupo_id)
        materia_idx = obtener_indice_materia(nodo.materia_id)
        
        asignado = Falso
        
        Para cada (dia, slot, profesor) en nodo.asignaciones_posibles:
            Si es_valido(nodo, grupo_idx, materia_idx, dia, slot, profesor):
                aplicar_movimiento(nodo, grupo_idx, materia_idx, dia, slot, profesor)
                asignado = Verdadero
                Salir del bucle interno
        
        Si NO asignado:
            Registrar advertencia
    
    Retornar Verdadero
\end{lstlisting}

\subsection{Ejemplo Ilustrativo}

Supongamos que tenemos que asignar 3 horas de ``Base de Datos'' al grupo ISC-3A:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Nodo} & \textbf{Opciones Disponibles} & \textbf{Decisión} \\
\midrule
BD-hora1 & (Lun-s1-Prof.López), (Lun-s2-Prof.García) & Lun-s1-Prof.López $\checkmark$ \\
BD-hora2 & (Lun-s2-Prof.López), (Mar-s1-Prof.López) & Lun-s2-Prof.López $\checkmark$ \\
BD-hora3 & (Mar-s1-Prof.López), (Mié-s1-Prof.López) & Mar-s1-Prof.López $\checkmark$ \\
\bottomrule
\end{tabular}
\caption{Ejemplo de asignación Greedy}
\end{table}

\subsection{Ventajas y Desventajas}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Ventajas} & \textbf{Desventajas} \\
\midrule
Muy rápido (milisegundos) & No garantiza solución óptima \\
Determinista & Puede quedarse atascado \\
Bajo consumo de memoria & No explora alternativas \\
Siempre termina & Sensible al orden de entrada \\
\bottomrule
\end{tabular}
\caption{Análisis del algoritmo Greedy}
\end{table}

\newpage
\section{Algoritmo Backtracking (Retroceso)}

\subsection{Definición}

El algoritmo \textbf{Backtracking} es una técnica de búsqueda exhaustiva que explora el espacio de soluciones de forma sistemática. A diferencia del Greedy, el Backtracking \textbf{puede deshacer decisiones} cuando detecta que un camino no lleva a una solución válida.

Es análogo a resolver un laberinto: si llegas a un callejón sin salida, retrocedes y pruebas otro camino.

\subsection{Complejidad}

\begin{equation}
O(A^N) \quad \text{(peor caso teórico)}
\end{equation}

En la práctica es mucho menor gracias a las podas agresivas de las restricciones.

\subsection{Funcionamiento Paso a Paso}

\begin{enumerate}
    \item \textbf{Estructura recursiva:} El algoritmo es una función que se llama a sí misma. Cada llamada intenta asignar un nodo específico (identificado por su índice).
    
    \item \textbf{Caso base:} Si el índice del nodo es igual al total de nodos, significa que todos fueron asignados exitosamente. ¡Se encontró una solución completa!
    
    \item \textbf{Exploración de opciones:} Para el nodo actual, el algoritmo prueba cada asignación posible (día, slot, profesor) una por una.
    
    \item \textbf{Validación:} Antes de aplicar una asignación, verifica que cumpla todas las restricciones.
    
    \item \textbf{Aplicar y recurrir:} Si la asignación es válida, la aplica y llama recursivamente a $\texttt{backtrack}(nodo\_idx + 1)$.
    
    \item \textbf{Retroceso:} Si la llamada recursiva retorna \texttt{False}, el algoritmo \textbf{deshace} la asignación y prueba la siguiente opción.
    
    \item \textbf{Agotamiento de opciones:} Si ninguna opción funciona, retorna \texttt{False}, causando que el nodo anterior también intente otra opción (efecto cascada).
\end{enumerate}

\subsection{Operaciones Apply y Undo}

El backtracking requiere poder \textbf{revertir} cada decisión:

\subsubsection{Aplicar Movimiento (apply\_move)}

\begin{lstlisting}[style=pseudocode]
prof_schedule[profesor][dia][slot] = 1       // Marcar ocupado
group_schedule[grupo][dia][slot] = 1         // Marcar ocupado
prof_load[profesor] += 1                     // Incrementar carga
group_materia_day_count[grupo][materia][dia] += 1
group_materia_day_slots[grupo][materia][dia] |= (1 << slot)  // Bitmask
\end{lstlisting}

\subsubsection{Deshacer Movimiento (undo\_move)}

\begin{lstlisting}[style=pseudocode]
prof_schedule[profesor][dia][slot] = 0       // Liberar
group_schedule[grupo][dia][slot] = 0         // Liberar
prof_load[profesor] -= 1                     // Decrementar
group_materia_day_count[grupo][materia][dia] -= 1
group_materia_day_slots[grupo][materia][dia] &= ~(1 << slot)  // Limpiar bit
\end{lstlisting}

\subsection{Control de Tiempo}

Dado que el Backtracking puede tardar horas en casos complejos, implementamos un sistema de límite de tiempo:

\begin{enumerate}
    \item \textbf{Contador de llamadas:} Se incrementa \texttt{call\_count} en cada llamada recursiva.
    \item \textbf{Verificación periódica:} Cada 1000 llamadas, se compara el tiempo transcurrido contra el límite.
    \item \textbf{Bandera de abort:} Si se excede el tiempo, \texttt{time\_limit\_reached = True}.
    \item \textbf{Propagación inmediata:} Todas las funciones verifican esta bandera y retornan inmediatamente.
    \item \textbf{Mejor solución parcial:} Se guarda la mejor solución encontrada hasta el momento.
\end{enumerate}

\subsection{Pseudocódigo Completo}

\begin{lstlisting}[style=pseudocode, caption={Algoritmo Backtracking}]
funcion backtrack(nodo_idx):
    call_count += 1
    
    // CONTROL DE TIEMPO
    Si call_count % 1000 == 0:
        Si time_limit_reached:
            Retornar Falso
        Si tiempo_actual() - tiempo_inicio > limite_tiempo:
            Imprimir "Tiempo limite alcanzado"
            time_limit_reached = Verdadero
            Retornar Falso
    
    // GUARDAR MEJOR SOLUCION PARCIAL
    Si nodo_idx > max_assigned_count:
        max_assigned_count = nodo_idx
        best_assignments = copiar_estado_actual()
        Imprimir "Nueva mejor solucion: {nodo_idx}/{total}"
    
    // CASO BASE: SOLUCION COMPLETA
    Si nodo_idx >= cantidad_de_nodos:
        Retornar Verdadero
    
    // VERIFICACION DE ABORT
    Si time_limit_reached:
        Retornar Falso
    
    // OBTENER NODO ACTUAL
    nodo = nodos[nodo_idx]
    grupo_idx = obtener_indice_grupo(nodo.grupo_id)
    materia_idx = obtener_indice_materia(nodo.materia_id)
    
    // EXPLORAR TODAS LAS OPCIONES
    Para cada (dia, slot, profesor) en nodo.asignaciones_posibles:
        
        Si time_limit_reached:
            Retornar Falso
        
        Si es_valido(nodo, grupo_idx, materia_idx, dia, slot, profesor):
            
            // PASO 1: Aplicar la asignacion
            aplicar_movimiento(nodo, grupo_idx, materia_idx, dia, slot, profesor)
            
            // PASO 2: Recurrir al siguiente nodo
            Si backtrack(nodo_idx + 1):
                Retornar Verdadero
            
            // PASO 3: Verificar abort
            Si time_limit_reached:
                deshacer_movimiento(...)
                Retornar Falso
            
            // PASO 4: Deshacer (BACKTRACK)
            deshacer_movimiento(nodo, grupo_idx, materia_idx, dia, slot, profesor)
    
    // NINGUNA OPCION FUNCIONO
    Retornar Falso
\end{lstlisting}

\subsection{Ejemplo: El Poder del Retroceso}

Consideremos un escenario donde el Greedy fallaría:

\textbf{Escenario:} 2 materias (A y B), 1 profesor común, solo 2 slots disponibles.
\begin{itemize}
    \item Materia A: 1 hora, puede ir en slot 1 o slot 2
    \item Materia B: 1 hora, SOLO puede ir en slot 1
\end{itemize}

\textbf{Greedy (falla):}
\begin{enumerate}
    \item Asigna A en slot 1 (primera opción válida)
    \item Intenta asignar B... ¡slot 1 ocupado!
    \item \textbf{Resultado:} B queda sin asignar $\times$
\end{enumerate}

\textbf{Backtracking (éxito):}
\begin{enumerate}
    \item Asigna A en slot 1
    \item Intenta asignar B en slot 1... falla
    \item \textbf{RETROCEDE:} Deshace A de slot 1
    \item Asigna A en slot 2
    \item Asigna B en slot 1... ¡éxito!
    \item \textbf{Resultado:} Ambas materias asignadas $\checkmark$
\end{enumerate}

\subsection{Árbol de Decisiones}

El backtracking puede visualizarse como un árbol donde cada nivel representa un nodo por asignar:

\begin{center}
\begin{tikzpicture}[
    level distance=1.5cm,
    level 1/.style={sibling distance=4cm},
    level 2/.style={sibling distance=2cm},
    edge from parent/.style={draw,-latex}
]
\node {Inicio}
    child {node {Nodo0-Op1}
        child {node {N1-1} 
            child {node {N2-1} edge from parent node[left] {$\times$}}
        }
        child {node {N1-2} edge from parent node[right] {$\times$}}
    }
    child {node {Nodo0-Op2}
        child {node {N1-1}
            child {node {$\checkmark$}}
        }
        child {node {N1-2}}
    }
    child {node {Nodo0-Op3}
        child {node {...}}
    };
\end{tikzpicture}
\end{center}

El algoritmo recorre el árbol en \textbf{profundidad primero} (DFS), retrocediendo cuando encuentra un callejón sin salida.

\subsection{Ventajas y Desventajas}

\begin{table}[h]
\centering
\begin{tabular}{ll}
\toprule
\textbf{Ventajas} & \textbf{Desventajas} \\
\midrule
Encuentra solución si existe & Puede ser muy lento \\
Explora todo el espacio de búsqueda & Mayor consumo de memoria \\
Devuelve mejor solución parcial & Complejidad exponencial teórica \\
Configurable con límite de tiempo & \\
\bottomrule
\end{tabular}
\caption{Análisis del algoritmo Backtracking}
\end{table}

\newpage
\section{Comparación de Algoritmos}

\begin{table}[h]
\centering
\begin{tabular}{lll}
\toprule
\textbf{Criterio} & \textbf{Greedy} & \textbf{Backtracking} \\
\midrule
Tiempo disponible & Poco (segundos) & Más (minutos) \\
Importancia de completar & Baja & Alta \\
Complejidad del problema & Simple & Compleja \\
Restricciones & Pocas/relajadas & Muchas/estrictas \\
Uso recomendado & Vista previa rápida & Generación final \\
\bottomrule
\end{tabular}
\caption{Comparación: ¿Cuándo usar cada algoritmo?}
\end{table}

\section{Restricciones Implementadas}

Ambos algoritmos validan las siguientes restricciones antes de cada asignación:

\begin{enumerate}
    \item \textbf{Profesor no ocupado:} $\texttt{prof\_schedule}[p][d][s] = 0$
    \item \textbf{Grupo no ocupado:} $\texttt{group\_schedule}[g][d][s] = 0$
    \item \textbf{Carga máxima de profesor:} $\texttt{prof\_load}[p] < \texttt{prof\_max\_load}[p]$
    \item \textbf{Consistencia de profesor:} El mismo profesor debe dar todas las horas de una materia al mismo grupo
    \item \textbf{Máximo 2 horas/día por materia:} $\texttt{group\_materia\_day\_count}[g][m][d] < 2$
    \item \textbf{Contigüidad de bloques:} Si hay 2 horas de una materia en un día, deben ser consecutivas
    \item \textbf{Máximo gap de 1 hora:} No puede haber huecos mayores a 1 slot entre clases
    \item \textbf{Máximo 7 horas/día por grupo:} Previene días excesivamente largos
\end{enumerate}

\subsection{Validación de Contigüidad}

Usa un \textbf{bitmask} para tracking eficiente:

\begin{lstlisting}[style=pseudocode]
Si count > 0:
    mask = group_materia_day_slots[grupo][materia][dia]
    adj_mask = (1 << (slot - 1)) | (1 << (slot + 1))
    Si (mask & adj_mask) == 0:
        Retornar Falso  // No es contiguo
\end{lstlisting}

\end{document}
